/* automatically generated by rust-bindgen 0.68.1 */

#![allow(warnings)]

pub const ZHM_TARGET: u32 = 3;
pub const _STL_COMPILER_PREPROCESSOR: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const _STL_WARNING_LEVEL: u32 = 3;
pub const _STL_DISABLED_WARNING_C4984: u32 = 4984;
pub const _STL_DISABLED_WARNING_C5053: u32 = 5053;
pub const _CPPLIB_VER: u32 = 650;
pub const _MSVC_STL_VERSION: u32 = 143;
pub const _MSVC_STL_UPDATE: u32 = 202208;
pub const _HAS_STATIC_RTTI: u32 = 1;
pub const _HAS_STD_BYTE: u32 = 0;
pub const _ENFORCE_MATCHING_ALLOCATORS: u32 = 0;
pub const _ENFORCE_FACET_SPECIALIZATIONS: u32 = 0;
pub const _FACET_SPECIALIZATION_MESSAGE : & [u8 ; 178] = b"Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 to suppress this error.\0" ;
pub const _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS: u32 = 1;
pub const _STD_VECTORIZE_WITH_FLOAT_CONTROL: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_shared_mutex: u32 = 201505;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_atomic_value_initialization: u32 = 201911;
pub const __cpp_lib_chrono: u32 = 201510;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_experimental_erase_if: u32 = 201411;
pub const __cpp_lib_experimental_filesystem: u32 = 201406;
pub const _STL_WIN32_WINNT_VISTA: u32 = 1536;
pub const _STL_WIN32_WINNT_WIN7: u32 = 1537;
pub const _STL_WIN32_WINNT_WIN8: u32 = 1538;
pub const _STL_WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _STL_WIN32_WINNT_WIN10: u32 = 2560;
pub const _STL_WIN32_WINNT: u32 = 1537;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 0;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
	pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
	pub _address: u8
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 = false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
	pub _address: u8
}
pub type __vcrt_bool = bool;
unsafe extern "C" {
	pub fn __security_init_cookie();
}
unsafe extern "C" {
	pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
	pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
	pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type std_integral_constant_value_type<_Ty> = _Ty;
pub type std_integral_constant_type = u8;
pub type std_bool_constant = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std_enable_if_t = u8;
pub type std_conditional_type<_Ty1> = _Ty1;
pub type std_conditional_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
	pub _address: u8
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
	pub _address: u8
}
pub type std_remove_const_type<_Ty> = _Ty;
pub type std_remove_const_t = std_remove_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
	pub _address: u8
}
pub type std_remove_volatile_type<_Ty> = _Ty;
pub type std_remove_volatile_t = std_remove_volatile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
	pub _address: u8
}
pub type std_remove_cv_type<_Ty> = _Ty;
pub type std_remove_cv__Apply = u8;
pub type std_remove_cv_t = std_remove_cv;
pub type std__Disjunction_type<_First> = _First;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_disjunction {
	pub _base: std_false_type
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
	pub _address: u8
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
	pub _address: u8
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
	pub _address: u8
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
	pub _address: u8
}
pub type std_remove_reference_type<_Ty> = _Ty;
pub type std_remove_reference__Const_thru_ref_type<_Ty> = _Ty;
pub type std_remove_reference_t = std_remove_reference;
pub type std__Const_thru_ref = std_remove_reference;
pub type std__Remove_cvref_t = std_remove_cv_t;
pub type std_max_align_t = f64;
pub type __crt_bool = bool;
unsafe extern "C" {
	pub fn _invalid_parameter_noinfo();
}
unsafe extern "C" {
	pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
unsafe extern "C" {
	pub fn _invoke_watson(
		_Expression: *const u16,
		_FunctionName: *const u16,
		_FileName: *const u16,
		_LineNo: ::std::os::raw::c_uint,
		_Reserved: usize
	) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
	pub _locale_pctype: *const ::std::os::raw::c_ushort,
	pub _locale_mb_cur_max: ::std::os::raw::c_int,
	pub _locale_lc_codepage: ::std::os::raw::c_uint
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
	const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__crt_locale_data_public>(),
		16usize,
		concat!("Size of: ", stringify!(__crt_locale_data_public))
	);
	assert_eq!(
		::std::mem::align_of::<__crt_locale_data_public>(),
		8usize,
		concat!("Alignment of ", stringify!(__crt_locale_data_public))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__crt_locale_data_public),
			"::",
			stringify!(_locale_pctype)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__crt_locale_data_public),
			"::",
			stringify!(_locale_mb_cur_max)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(__crt_locale_data_public),
			"::",
			stringify!(_locale_lc_codepage)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
	pub locinfo: *mut __crt_locale_data,
	pub mbcinfo: *mut __crt_multibyte_data
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
	const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__crt_locale_pointers>(),
		16usize,
		concat!("Size of: ", stringify!(__crt_locale_pointers))
	);
	assert_eq!(
		::std::mem::align_of::<__crt_locale_pointers>(),
		8usize,
		concat!("Alignment of ", stringify!(__crt_locale_pointers))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__crt_locale_pointers),
			"::",
			stringify!(locinfo)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__crt_locale_pointers),
			"::",
			stringify!(mbcinfo)
		)
	);
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
	pub _Wchar: ::std::os::raw::c_ulong,
	pub _Byte: ::std::os::raw::c_ushort,
	pub _State: ::std::os::raw::c_ushort
}
#[test]
fn bindgen_test_layout__Mbstatet() {
	const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Mbstatet>(),
		8usize,
		concat!("Size of: ", stringify!(_Mbstatet))
	);
	assert_eq!(
		::std::mem::align_of::<_Mbstatet>(),
		4usize,
		concat!("Alignment of ", stringify!(_Mbstatet))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_Mbstatet), "::", stringify!(_Wchar))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
		4usize,
		concat!("Offset of field: ", stringify!(_Mbstatet), "::", stringify!(_Byte))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
		6usize,
		concat!("Offset of field: ", stringify!(_Mbstatet), "::", stringify!(_State))
	);
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
unsafe extern "C" {
	pub fn _errno() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
	pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
unsafe extern "C" {
	pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
unsafe extern "C" {
	pub fn __threadid() -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
	pub fn __threadhandle() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceConverter {
	#[doc = " Convert a binary resource found at [p_ResourceFilePath] to its json representation and\n store it in \
	         the [p_OutputFilePath] file on the filesystem.\n\n Returns [true] on success, or [false] otherwise."]
	pub FromResourceFileToJsonFile: ::std::option::Option<
		unsafe extern "C" fn(
			p_ResourceFilePath: *const ::std::os::raw::c_char,
			p_OutputFilePath: *const ::std::os::raw::c_char
		) -> bool
	>,
	#[doc = " Convert a resource from an in-memory buffer to its json representation and store it in\n the \
	         [p_OutputFilePath] file on the filesystem. The [p_ResourceData] parameter must\n point to the binary \
	         data of the resource and the [p_Size] parameter must be the size of\n the resource in bytes.\n\n Returns \
	         [true] on success, or [false] otherwise."]
	pub FromMemoryToJsonFile: ::std::option::Option<
		unsafe extern "C" fn(
			p_ResourceData: *const ::std::os::raw::c_void,
			p_Size: usize,
			p_OutputFilePath: *const ::std::os::raw::c_char
		) -> bool
	>,
	#[doc = " Convert a binary resource found at [p_ResourceFilePath] to its json representation and\n store it in \
	         memory as a [JsonString]. After using it, the [JsonString] must be cleaned up\n by passing it to the \
	         [FreeJsonString] function.\n\n If the operation fails, this function will return [nullptr]."]
	pub FromResourceFileToJsonString: ::std::option::Option<
		unsafe extern "C" fn(p_ResourceFilePath: *const ::std::os::raw::c_char) -> *mut JsonString
	>,
	#[doc = " Convert a resource from an in-memory buffer to its json representation and store it in\n memory as a \
	         [JsonString]. The [p_ResourceData] parameter must point to the binary data\n of the resource and the \
	         [p_Size] parameter must be the size of the resource in bytes.\n After using it, the [JsonString] must be \
	         cleaned up by passing it to the\n [FreeJsonString] function.\n\n If the operation fails, this function \
	         will return [nullptr]."]
	pub FromMemoryToJsonString: ::std::option::Option<
		unsafe extern "C" fn(p_ResourceData: *const ::std::os::raw::c_void, p_Size: usize) -> *mut JsonString
	>,
	#[doc = " Clean up an in-memory json string. The [JsonString] becomes invalid after a call to\n this function, \
	         and attempting to use it results in undefined behavior."]
	pub FreeJsonString: ::std::option::Option<unsafe extern "C" fn(p_JsonString: *mut JsonString)>
}
#[test]
fn bindgen_test_layout_ResourceConverter() {
	const UNINIT: ::std::mem::MaybeUninit<ResourceConverter> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ResourceConverter>(),
		40usize,
		concat!("Size of: ", stringify!(ResourceConverter))
	);
	assert_eq!(
		::std::mem::align_of::<ResourceConverter>(),
		8usize,
		concat!("Alignment of ", stringify!(ResourceConverter))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromResourceFileToJsonFile) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceConverter),
			"::",
			stringify!(FromResourceFileToJsonFile)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromMemoryToJsonFile) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceConverter),
			"::",
			stringify!(FromMemoryToJsonFile)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromResourceFileToJsonString) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceConverter),
			"::",
			stringify!(FromResourceFileToJsonString)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromMemoryToJsonString) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceConverter),
			"::",
			stringify!(FromMemoryToJsonString)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FreeJsonString) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceConverter),
			"::",
			stringify!(FreeJsonString)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceGenerator {
	#[doc = " Generate a new binary resource from the json file found at [p_JsonFilePath] and store it\n in the \
	         [p_ResourceFilePath] file on the filesystem.\n\n The [p_GenerateCompatible] parameter specifies whether \
	         the generated resource should try to\n maintain compatibility with the quirks of the original BIN1 \
	         format. Doesn't matter when\n producing files for use in the game, but certain third party tools might \
	         behave better with them.\n Generating \"compatible\" resources can take significantly longer.\n\n \
	         Returns [true] on success, or [false] otherwise."]
	pub FromJsonFileToResourceFile: ::std::option::Option<
		unsafe extern "C" fn(
			p_JsonFilePath: *const ::std::os::raw::c_char,
			p_ResourceFilePath: *const ::std::os::raw::c_char,
			p_GenerateCompatible: bool
		) -> bool
	>,
	#[doc = " Generate a new binary resource from the specified json string and store it in the\n \
	         [p_ResourceFilePath] file on the filesystem. The [p_JsonStr] must point to the json\n string data and \
	         the [p_JsonStrLength] must be the length of the data, excluding any\n null terminators.\n\n The \
	         [p_GenerateCompatible] parameter specifies whether the generated resource should try to\n maintain \
	         compatibility with the quirks of the original BIN1 format. Doesn't matter when\n producing files for use \
	         in the game, but certain third party tools might behave better with them.\n Generating \"compatible\" \
	         resources can take significantly longer.\n\n Returns [true] on success, or [false] otherwise."]
	pub FromJsonStringToResourceFile: ::std::option::Option<
		unsafe extern "C" fn(
			p_JsonStr: *const ::std::os::raw::c_char,
			p_JsonStrLength: usize,
			p_ResourceFilePath: *const ::std::os::raw::c_char,
			p_GenerateCompatible: bool
		) -> bool
	>,
	#[doc = " Generate a new binary resource from the json file found at [p_JsonFilePath] and store it\n in memory as \
	         a [ResourceMem]. After using it, the [ResourceMem] must be cleaned up\n by passing it to the \
	         [FreeResourceMem] function.\n\n The [p_GenerateCompatible] parameter specifies whether the generated \
	         resource should try to\n maintain compatibility with the quirks of the original BIN1 format. Doesn't \
	         matter when\n producing files for use in the game, but certain third party tools might behave better \
	         with them.\n Generating \"compatible\" resources can take significantly longer.\n\n If the operation \
	         fails, this function will return [nullptr]."]
	pub FromJsonFileToResourceMem: ::std::option::Option<
		unsafe extern "C" fn(
			p_JsonFilePath: *const ::std::os::raw::c_char,
			p_GenerateCompatible: bool
		) -> *mut ResourceMem
	>,
	#[doc = " Generate a new binary resource from the specified json string and store it in memory as\n a \
	         [ResourceMem]. The [p_JsonStr] must point to the json string data and the\n [p_JsonStrLength] must be \
	         the length of the data, excluding any null terminators. After\n using it, the [ResourceMem] must be \
	         cleaned up by passing it to the [FreeResourceMem]\n function.\n\n The [p_GenerateCompatible] parameter \
	         specifies whether the generated resource should try to\n maintain compatibility with the quirks of the \
	         original BIN1 format. Doesn't matter when\n producing files for use in the game, but certain third party \
	         tools might behave better with them.\n Generating \"compatible\" resources can take significantly \
	         longer.\n\n If the operation fails, this function will return [nullptr]."]
	pub FromJsonStringToResourceMem: ::std::option::Option<
		unsafe extern "C" fn(
			p_JsonStr: *const ::std::os::raw::c_char,
			p_JsonStrLength: usize,
			p_GenerateCompatible: bool
		) -> *mut ResourceMem
	>,
	#[doc = " Clean up an in-memory binary resource. The [ResourceMem] becomes invalid after a call\n to this \
	         function, and attempting to use it results in undefined behavior."]
	pub FreeResourceMem: ::std::option::Option<unsafe extern "C" fn(p_ResourceMem: *mut ResourceMem)>
}
#[test]
fn bindgen_test_layout_ResourceGenerator() {
	const UNINIT: ::std::mem::MaybeUninit<ResourceGenerator> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ResourceGenerator>(),
		40usize,
		concat!("Size of: ", stringify!(ResourceGenerator))
	);
	assert_eq!(
		::std::mem::align_of::<ResourceGenerator>(),
		8usize,
		concat!("Alignment of ", stringify!(ResourceGenerator))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromJsonFileToResourceFile) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceGenerator),
			"::",
			stringify!(FromJsonFileToResourceFile)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromJsonStringToResourceFile) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceGenerator),
			"::",
			stringify!(FromJsonStringToResourceFile)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromJsonFileToResourceMem) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceGenerator),
			"::",
			stringify!(FromJsonFileToResourceMem)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FromJsonStringToResourceMem) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceGenerator),
			"::",
			stringify!(FromJsonStringToResourceMem)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).FreeResourceMem) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceGenerator),
			"::",
			stringify!(FreeResourceMem)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonString {
	#[doc = " The json string data. Is always null terminated."]
	pub JsonData: *const ::std::os::raw::c_char,
	#[doc = " The length of the json string data. Does not include the null terminator."]
	pub StrSize: usize
}
#[test]
fn bindgen_test_layout_JsonString() {
	const UNINIT: ::std::mem::MaybeUninit<JsonString> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<JsonString>(),
		16usize,
		concat!("Size of: ", stringify!(JsonString))
	);
	assert_eq!(
		::std::mem::align_of::<JsonString>(),
		8usize,
		concat!("Alignment of ", stringify!(JsonString))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).JsonData) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(JsonString), "::", stringify!(JsonData))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).StrSize) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(JsonString), "::", stringify!(StrSize))
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceMem {
	pub ResourceData: *const ::std::os::raw::c_void,
	pub DataSize: usize
}
#[test]
fn bindgen_test_layout_ResourceMem() {
	const UNINIT: ::std::mem::MaybeUninit<ResourceMem> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ResourceMem>(),
		16usize,
		concat!("Size of: ", stringify!(ResourceMem))
	);
	assert_eq!(
		::std::mem::align_of::<ResourceMem>(),
		8usize,
		concat!("Alignment of ", stringify!(ResourceMem))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).ResourceData) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceMem),
			"::",
			stringify!(ResourceData)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).DataSize) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ResourceMem), "::", stringify!(DataSize))
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceTypesArray {
	pub Types: *mut *const ::std::os::raw::c_char,
	pub TypeCount: usize
}
#[test]
fn bindgen_test_layout_ResourceTypesArray() {
	const UNINIT: ::std::mem::MaybeUninit<ResourceTypesArray> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ResourceTypesArray>(),
		16usize,
		concat!("Size of: ", stringify!(ResourceTypesArray))
	);
	assert_eq!(
		::std::mem::align_of::<ResourceTypesArray>(),
		8usize,
		concat!("Alignment of ", stringify!(ResourceTypesArray))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).Types) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceTypesArray),
			"::",
			stringify!(Types)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).TypeCount) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(ResourceTypesArray),
			"::",
			stringify!(TypeCount)
		)
	);
}
#[doc = " A read-only view of a string.\n The string is not guaranteed to be null terminated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringView {
	pub Data: *const ::std::os::raw::c_char,
	pub Size: usize
}
#[test]
fn bindgen_test_layout_StringView() {
	const UNINIT: ::std::mem::MaybeUninit<StringView> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<StringView>(),
		16usize,
		concat!("Size of: ", stringify!(StringView))
	);
	assert_eq!(
		::std::mem::align_of::<StringView>(),
		8usize,
		concat!("Alignment of ", stringify!(StringView))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(StringView), "::", stringify!(Data))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(StringView), "::", stringify!(Size))
	);
}
unsafe extern "C" {
	pub fn HM3_GetConverterForResource(p_ResourceType: *const ::std::os::raw::c_char) -> *mut ResourceConverter;
}
unsafe extern "C" {
	pub fn HM3_GetGeneratorForResource(p_ResourceType: *const ::std::os::raw::c_char) -> *mut ResourceGenerator;
}
unsafe extern "C" {
	pub fn HM3_GetSupportedResourceTypes() -> *mut ResourceTypesArray;
}
unsafe extern "C" {
	pub fn HM3_FreeSupportedResourceTypes(p_Array: *mut ResourceTypesArray);
}
unsafe extern "C" {
	pub fn HM3_IsResourceTypeSupported(p_ResourceType: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
	pub fn HM3_GameStructToJson(
		p_StructureType: *const ::std::os::raw::c_char,
		p_Structure: *const ::std::os::raw::c_void,
		p_Size: usize
	) -> *mut JsonString;
}
unsafe extern "C" {
	pub fn HM3_JsonToGameStruct(
		p_StructureType: *const ::std::os::raw::c_char,
		p_JsonStr: *const ::std::os::raw::c_char,
		p_JsonStrLength: usize,
		p_TargetMemory: *mut ::std::os::raw::c_void,
		p_TargetMemorySize: usize
	) -> bool;
}
unsafe extern "C" {
	pub fn HM3_FreeJsonString(p_JsonString: *mut JsonString);
}
unsafe extern "C" {
	pub fn HM3_GetPropertyName(p_PropertyId: u32) -> StringView;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
	pub _address: u8
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
	pub _address: u8
}
